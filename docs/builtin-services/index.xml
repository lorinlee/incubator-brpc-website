<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bRPC – Builtin Services</title><link>https://brpc.apache.org/docs/builtin-services/</link><description>Recent content in Builtin Services on bRPC</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 12 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://brpc.apache.org/docs/builtin-services/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: builtin services</title><link>https://brpc.apache.org/docs/builtin-services/buildin_services/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/buildin_services/</guid><description>
&lt;h1 id="builtin-services">Builtin Services&lt;/h1>
&lt;p>Builtin services expose internal status of servers in different pespectives, making development and debugging over brpc more efficient. brpc serves builting services via HTTP, which can be easily accessed through curl and web browsers. Servers respond plain text or html according to &lt;code>User-Agent&lt;/code> in the request header, or you may append &lt;code>?console=1&lt;/code> to the uri to force the server to respond in plain text. Check the &lt;a href="http://brpc.baidu.com:8765/">example&lt;/a> running on our dev machine(only accessible from Baidu internal) for more details. If the port is forbidden from where you run curl or web browser (e.g. not all ports are accessible from a web browser inside Baidu), you can use &lt;a href="../../tools/rpc_view/">rpc_view&lt;/a> for proxying.&lt;/p>
&lt;p>Following 2 screenshots show accesses to builtin services from a web browser and a terminal respectively. Note that the logo is the codename inside Baidu, and being modified to brpc in opensourced version.&lt;/p>
&lt;p>&lt;strong>From a web browser&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/builtin_service_more.png" alt="img">&lt;/p>
&lt;p>&lt;strong>From a terminal&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/builtin_service_from_console.png" alt="img">&lt;/p>
&lt;h1 id="security-mode">Security Mode&lt;/h1>
&lt;p>To avoid potential attacks and information leaks, builtin services &lt;strong>must&lt;/strong> be hidden on servers that may be accessed from public, including the ones proxied by nginx or other http servers. Click &lt;a href="../../server/basics/#security-mode">here&lt;/a> for more details.&lt;/p>
&lt;h1 id="main-services">Main services:&lt;/h1>
&lt;p>&lt;a href="../status/">/status&lt;/a>: displays brief status of all services.&lt;/p>
&lt;p>&lt;a href="../vars/">/vars&lt;/a>: lists user-customizable counters on miscellaneous metrics.&lt;/p>
&lt;p>&lt;a href="../connections/">/connections&lt;/a>: lists all connections and their stats.&lt;/p>
&lt;p>&lt;a href="../flags/">/flags&lt;/a>: lists all gflags, some of them are modifiable at run-time.&lt;/p>
&lt;p>&lt;a href="../rpcz/">/rpcz&lt;/a>: traces all RPCs.&lt;/p>
&lt;p>&lt;a href="../cpu_profiler/">cpu profiler&lt;/a>: analyzes CPU hotspots.&lt;/p>
&lt;p>&lt;a href="../heap_profiler/">heap profiler&lt;/a>: shows how memory are allocated.&lt;/p>
&lt;p>&lt;a href="../contention_profiler/">contention profiler&lt;/a>: analyzes lock contentions.&lt;/p>
&lt;h1 id="other-services">Other services&lt;/h1>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/version">/version&lt;/a> shows version of the server. Call Server::set_version() to specify version of the server, or brpc would generate a default version like &lt;code>brpc_server_&amp;lt;service-name1&amp;gt;_&amp;lt;service-name2&amp;gt; ...&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/version_service.png" alt="img">&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/health">/health&lt;/a> shows whether this server is alive or not.&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/health_service.png" alt="img">&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/protobufs">/protobufs&lt;/a> shows scheme of all protobuf messages inside the server.&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/protobufs_service.png" alt="img">&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vlog">/vlog&lt;/a> shows all the &lt;a href="../../c++-base/streaming-log/#vlog">VLOG&lt;/a> that can be enabled(not working with glog).&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vlog_service.png" alt="img">&lt;/p>
&lt;p>/dir: browses all files on the server, convenient but too dangerous, disabled by default.&lt;/p>
&lt;p>/threads: displays information of all threads of the process, hurting performance significantly when being turned on, disabled by default.&lt;/p></description></item><item><title>Docs: status</title><link>https://brpc.apache.org/docs/builtin-services/status/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/status/</guid><description>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/status">/status&lt;/a> shows primary statistics of services inside the server. The data sources are same with &lt;a href="../vars/">/vars&lt;/a>, but stats are grouped differently.&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/status.png" alt="img">&lt;/p>
&lt;p>Meanings of the fields above:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>non_service_error&lt;/strong>: number of errors raised outside processing code of the service. When a valid service is obtained, the subsequent error is regarded as &lt;em>service_error&lt;/em>, otherwise it is regarded as &lt;em>non_service_error&lt;/em> (such as request parsing failed, service name does not exist, request concurrency exceeding limit, etc.). As a contrast, failing to access back-end servers during the processing is an error of the service, not a &lt;em>non_service_error&lt;/em>. Even if the response written out successfully stands for failure, the error is counted into the service rather than &lt;em>non_service_error&lt;/em>.&lt;/li>
&lt;li>&lt;strong>connection_count&lt;/strong>: number of connections to the server from clients, not including number of outward connections which are displayed at /vars/rpc_channel_connection_count.&lt;/li>
&lt;li>&lt;strong>example.EchoService&lt;/strong>: Full name of the service, including the package name defined in proto.&lt;/li>
&lt;li>&lt;strong>Echo (EchoRequest) returns (EchoResponse)&lt;/strong>: Signature of the method. A service can have multiple methods. Click links on request/response to see schemes of the protobuf messages.&lt;/li>
&lt;li>&lt;strong>count&lt;/strong>: Number of requests that are succesfully processed.&lt;/li>
&lt;li>&lt;strong>error&lt;/strong>: Number of requests that are failed to process.&lt;/li>
&lt;li>&lt;strong>latency&lt;/strong>: average latency in recent &lt;em>60s/60m/24h/30d&lt;/em> from &lt;em>right to left&lt;/em> on html, average latency in recent 10s(by default, specified by &lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>) on plain texts.&lt;/li>
&lt;li>&lt;strong>latency_percentiles&lt;/strong>: 80%, 90%, 99%, 99.9% percentiles of latency in 10 seconds(specified by&lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>). Curves with historical values are shown on html.&lt;/li>
&lt;li>&lt;strong>latency_cdf&lt;/strong>: shows percentiles as &lt;a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">CDF&lt;/a>, only available on html.&lt;/li>
&lt;li>&lt;strong>max_latency&lt;/strong>: max latency in recent &lt;em>60s/60m/24h/30d&lt;/em> from &lt;em>right to left&lt;/em> on html, max latency in recent 10s(by default, specified by &lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>) on plain texts.&lt;/li>
&lt;li>&lt;strong>qps&lt;/strong>: QPS(Queries Per Second) in recent &lt;em>60s/60m/24h/30d&lt;/em> from &lt;em>right to left&lt;/em> on html. QPS in recent 10s(by default, specified by &lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>) on plain texts.&lt;/li>
&lt;li>&lt;strong>processing&lt;/strong>: (renamed to concurrency in master) Number of requests being processed by the method. If this counter can&amp;rsquo;t hit zero when the traffic to the service becomes zero, the server probably has bugs, such as forgetting to call done-&amp;gt;Run() or stuck on some processing steps.&lt;/li>
&lt;/ul>
&lt;p>Users may customize descriptions on /status by letting the service implement &lt;a href="https://github.com/brpc/brpc/blob/master/src/brpc/describable.h">brpc::Describable&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">MyService&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">public&lt;/span> &lt;span style="color:#000">XXXService&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">public&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">Describable&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">public&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">Describe&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">std&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">ostream&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">os&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">DescribeOptions&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">options&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">os&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;my_status: blahblah&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For example:&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/status_2.png" alt="img">&lt;/p></description></item><item><title>Docs: vars</title><link>https://brpc.apache.org/docs/builtin-services/vars/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/vars/</guid><description>
&lt;p>&lt;a href="https://github.com/brpc/brpc/tree/master/src/bvar/">bvar&lt;/a> is a set of counters to record and view miscellaneous statistics conveniently in multi-threaded applications. The implementation reduces cache bouncing by storing data in thread local storage(TLS), being much faster than UbMonitor(a legacy counting library inside Baidu) and even atomic operations in highly contended scenarios. brpc integrates bvar by default, namely all exposed bvars in a server are accessible through &lt;a href="http://brpc.baidu.com:8765/vars">/vars&lt;/a>, and a single bvar is addressable by &lt;a href="http://brpc.baidu.com:8765/vars/rpc_socket_count">/vars/VARNAME&lt;/a>. Read &lt;a href="../../bvar/bvar/">bvar&lt;/a> to know how to add bvars for your program. brpc extensively use bvar to expose internal status. If you are looking for an utility to collect and display metrics of your application, consider bvar in the first place. bvar definitely can&amp;rsquo;t replace all counters, essentially it moves contentions occurred during write to read: which needs to combine all data written by all threads and becomes much slower than an ordinary read. If read and write on the counter are both frequent or decisions need to be made based on latest values, you should not use bvar.&lt;/p>
&lt;h2 id="query-methods">Query methods&lt;/h2>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars">/vars&lt;/a> : List all exposed bvars&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars/rpc_socket_count">/vars/NAME&lt;/a>：List the bvar whose name is &lt;code>NAME&lt;/code>&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars/pid;process_cpu_usage;rpc_controller_count">/vars/NAME1,NAME2,NAME3&lt;/a>：List bvars whose names are either &lt;code>NAME1&lt;/code>, &lt;code>NAME2&lt;/code> or &lt;code>NAME3&lt;/code>.&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars/rpc_server*_count;iobuf_blo$k_*">/vars/foo*,b$r&lt;/a>: List bvars whose names match given wildcard patterns. Note that &lt;code>$&lt;/code> matches a single character instead of &lt;code>?&lt;/code> which is a reserved character in URL.&lt;/p>
&lt;p>Following animation shows how to find bvars with wildcard patterns. You can copy and paste the URL to others who will see same bvars that you see. (values may change)&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vars_1.gif" alt="img">&lt;/p>
&lt;p>There&amp;rsquo;s a search box in the upper-left corner on /vars page, in which you can type part of the names to locate bvars. Different patterns are separated by &lt;code>,&lt;/code> &lt;code>:&lt;/code> or space.&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vars_2.gif" alt="img">&lt;/p>
&lt;p>/vars is accessible from terminal as well:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ curl brpc.baidu.com:8765/vars/bthread*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_count : &lt;span style="color:#0000cf;font-weight:bold">125134&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency : &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency_50 : &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency_90 : &lt;span style="color:#0000cf;font-weight:bold">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency_99 : &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency_999 : &lt;span style="color:#0000cf;font-weight:bold">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency_9999 : &lt;span style="color:#0000cf;font-weight:bold">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency_cdf : &lt;span style="color:#4e9a06">&amp;#34;click to view&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_latency_percentiles : &lt;span style="color:#4e9a06">&amp;#34;[3,5,7,12]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_max_latency : &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_creation_qps : &lt;span style="color:#0000cf;font-weight:bold">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_group_status : &lt;span style="color:#4e9a06">&amp;#34;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_num_workers : &lt;span style="color:#0000cf;font-weight:bold">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bthread_worker_usage : 1.01056
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="view-historical-trends">View historical trends&lt;/h2>
&lt;p>Clicking on most of the numerical bvars shows historical trends. Each clickable bvar records values in recent &lt;em>60 seconds, 60 minutes, 24 hours and 30 days&lt;/em>, which are &lt;em>174&lt;/em> numbers in total. 1000 clickable bvars take roughly 1M memory.&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vars_3.gif" alt="img">&lt;/p>
&lt;h2 id="calculate-and-view-percentiles">Calculate and view percentiles&lt;/h2>
&lt;p>x-ile (short for x-th percentile) is the value ranked at N * x%-th position amongst a group of ordered values. E.g. If there&amp;rsquo;re 1000 values inside a time window, sort them in ascending order first. The 500-th value(1000 * 50%) in the ordered list is 50-ile(a.k.a median), the 990-th(1000 * 99%) value is 99-ile, the 999-th value is 99.9-ile. Percentiles give more information on how latencies distribute than mean values, and being helpful for analyzing behavior of the system more accurately. Industrial-grade services often require SLA to be not less than 99.97% (the requirement for 2nd-level services inside Baidu, &amp;gt;=99.99% for 1st-level services), even if a system has good average latencies, a bad long-tail area may still break SLA. Percentiles do help analyzing the long-tail area.&lt;/p>
&lt;p>Percentiles can be plotted as a CDF or percentiles-over-time curve.&lt;/p>
&lt;p>&lt;strong>Following diagram plots percentiles as CDF&lt;/strong>, where the X-axis is the ratio(ranked-position/total-number) and the Y-axis is the corresponding percentile. E.g. The Y value corresponding to X=50% is 50-ile. If a system requires that &amp;ldquo;99.9% requests need to be processed within Y milliseconds&amp;rdquo;, you should check the Y at 99.9%.&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vars_4.png" alt="img">&lt;/p>
&lt;p>Why do we call it &lt;a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">CDF&lt;/a> ? When a Y=y is chosen, the corresponding X means &amp;ldquo;percentage of values &amp;lt;= y&amp;rdquo;. Since values are sampled randomly (and uniformly), the X can be viewed as &amp;ldquo;probability of values &amp;lt;= y&amp;rdquo;, or P(values &amp;lt;= y), which is just the definition of CDF.&lt;/p>
&lt;p>Derivative of the CDF is &lt;a href="https://en.wikipedia.org/wiki/Probability_density_function">PDF&lt;/a>. If we divide the Y-axis of the CDF into many small-range segments, calculate the difference between X values of both ends of each segment, and use the difference as new value for X-axis, a PDF curve would be plotted, just like a normal distribution rotated 90 degrees clockwise. However density of the median is often much higher than others in a PDF and probably make long-tail area very flat and hard to read. As a result, systems prefer showing distributions in CDF rather than PDF.&lt;/p>
&lt;p>Here&amp;rsquo;re 2 simple rules to check if a CDF curve is good or not:&lt;/p>
&lt;ul>
&lt;li>The flatter the better. A horizontal line is an ideal CDF curve which means that there&amp;rsquo;re no waitings, congestions or pauses, very unlikely in practice.&lt;/li>
&lt;li>The area between 99% and 100% should be as small as possible: right-side of 99% is the long-tail area, which has a significant impact on SLA.&lt;/li>
&lt;/ul>
&lt;p>A CDF with slowly ascending curve and small long-tail area is great in practice.&lt;/p>
&lt;p>&lt;strong>Following diagram plots percentiles over time&lt;/strong> and has four curves. The X-axis is time and Y-axis from top to bottom are 99.9% 99% 90% 50% percentiles respectively, plotted in lighter and lighter colors (from orange to yellow).&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vars_5.png" alt="img">&lt;/p>
&lt;p>Hovering mouse over the curves shows corresponding values at the time. The tooltip in above diagram means &amp;ldquo;The 99% percentile of latency before 39 seconds is 330 &lt;strong>microseconds&lt;/strong>&amp;rdquo;. The diagram does not include the 99.99-ile curve which is usually significantly higher than others, making others hard to read. You may click bvars ended with &amp;ldquo;_latency_9999&amp;rdquo; to read the 99.99-ile curve separately. This diagram shows how percentiles change over time, which is helpful to analyze performance regressions of systems.&lt;/p>
&lt;p>brpc calculates latency distributions of services automatically, which do not need users to add manually. The metrics are as follows:&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vars_6.png" alt="img">&lt;/p>
&lt;p>&lt;code>bvar::LatencyRecorder&lt;/code> is able to calculate latency distributions of any code, as depicted below. (checkout &lt;a href="../../bvar/bvar-c++/">bvar-c++&lt;/a> for details):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#include&lt;/span> &lt;span style="color:#8f5902;font-style:italic">&amp;lt;bvar/bvar.h&amp;gt;&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">bvar&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">LatencyRecorder&lt;/span> &lt;span style="color:#000">g_latency_recorder&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;client&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// expose this recorder
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">foo&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">g_latency_recorder&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#000">my_latency&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If the application already starts a brpc server, values like &lt;code>client_latency&lt;/code>, &lt;code>client_latency_cdf&lt;/code> can be viewed from &lt;code>/vars&lt;/code> as follows. Clicking them to see (dynamically-updated) curves:&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/vars_7.png" alt="img">&lt;/p>
&lt;h2 id="non-brpc-server">Non brpc server&lt;/h2>
&lt;p>If your program only uses brpc client or even not use brpc, and you also want to view the curves, check &lt;a href="../../client/dummy-server/">here&lt;/a>.&lt;/p></description></item><item><title>Docs: connections</title><link>https://brpc.apache.org/docs/builtin-services/connections/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/connections/</guid><description>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/connections">connections服务&lt;/a>可以查看所有的连接。一个典型的页面如下：&lt;/p>
&lt;p>server_socket_count: 5&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CreatedTime&lt;/th>
&lt;th>RemoteSide&lt;/th>
&lt;th>SSL&lt;/th>
&lt;th>Protocol&lt;/th>
&lt;th>fd&lt;/th>
&lt;th>BytesIn/s&lt;/th>
&lt;th>In/s&lt;/th>
&lt;th>BytesOut/s&lt;/th>
&lt;th>Out/s&lt;/th>
&lt;th>BytesIn/m&lt;/th>
&lt;th>In/m&lt;/th>
&lt;th>BytesOut/m&lt;/th>
&lt;th>Out/m&lt;/th>
&lt;th>SocketId&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2015/09/21-21:32:09.630840&lt;/td>
&lt;td>172.22.38.217:51379&lt;/td>
&lt;td>No&lt;/td>
&lt;td>http&lt;/td>
&lt;td>19&lt;/td>
&lt;td>1300&lt;/td>
&lt;td>1&lt;/td>
&lt;td>269&lt;/td>
&lt;td>1&lt;/td>
&lt;td>68844&lt;/td>
&lt;td>53&lt;/td>
&lt;td>115860&lt;/td>
&lt;td>53&lt;/td>
&lt;td>257&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:09.630857&lt;/td>
&lt;td>172.22.38.217:51380&lt;/td>
&lt;td>No&lt;/td>
&lt;td>http&lt;/td>
&lt;td>20&lt;/td>
&lt;td>1308&lt;/td>
&lt;td>1&lt;/td>
&lt;td>5766&lt;/td>
&lt;td>1&lt;/td>
&lt;td>68884&lt;/td>
&lt;td>53&lt;/td>
&lt;td>129978&lt;/td>
&lt;td>53&lt;/td>
&lt;td>258&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:09.630880&lt;/td>
&lt;td>172.22.38.217:51381&lt;/td>
&lt;td>No&lt;/td>
&lt;td>http&lt;/td>
&lt;td>21&lt;/td>
&lt;td>1292&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1447&lt;/td>
&lt;td>1&lt;/td>
&lt;td>67672&lt;/td>
&lt;td>52&lt;/td>
&lt;td>143414&lt;/td>
&lt;td>52&lt;/td>
&lt;td>259&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:01.324587&lt;/td>
&lt;td>127.0.0.1:55385&lt;/td>
&lt;td>No&lt;/td>
&lt;td>baidu_std&lt;/td>
&lt;td>15&lt;/td>
&lt;td>1480&lt;/td>
&lt;td>20&lt;/td>
&lt;td>880&lt;/td>
&lt;td>20&lt;/td>
&lt;td>88020&lt;/td>
&lt;td>1192&lt;/td>
&lt;td>52260&lt;/td>
&lt;td>1192&lt;/td>
&lt;td>512&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:01.325969&lt;/td>
&lt;td>127.0.0.1:55387&lt;/td>
&lt;td>No&lt;/td>
&lt;td>baidu_std&lt;/td>
&lt;td>17&lt;/td>
&lt;td>4016&lt;/td>
&lt;td>40&lt;/td>
&lt;td>1554&lt;/td>
&lt;td>40&lt;/td>
&lt;td>238879&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>92660&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>1024&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>channel_socket_count: 1&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CreatedTime&lt;/th>
&lt;th>RemoteSide&lt;/th>
&lt;th>SSL&lt;/th>
&lt;th>Protocol&lt;/th>
&lt;th>fd&lt;/th>
&lt;th>BytesIn/s&lt;/th>
&lt;th>In/s&lt;/th>
&lt;th>BytesOut/s&lt;/th>
&lt;th>Out/s&lt;/th>
&lt;th>BytesIn/m&lt;/th>
&lt;th>In/m&lt;/th>
&lt;th>BytesOut/m&lt;/th>
&lt;th>Out/m&lt;/th>
&lt;th>SocketId&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2015/09/21-21:32:01.325870&lt;/td>
&lt;td>127.0.0.1:8765&lt;/td>
&lt;td>No&lt;/td>
&lt;td>baidu_std&lt;/td>
&lt;td>16&lt;/td>
&lt;td>1554&lt;/td>
&lt;td>40&lt;/td>
&lt;td>4016&lt;/td>
&lt;td>40&lt;/td>
&lt;td>92660&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>238879&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>channel_short_socket_count: 0&lt;/p>
&lt;p>上述信息分为三段：&lt;/p>
&lt;ul>
&lt;li>第一段是server接受(accept)的连接。&lt;/li>
&lt;li>第二段是server与下游的单连接（使用brpc::Channel建立），fd为-1的是虚拟连接，对应第三段中所有相同RemoteSide的连接。&lt;/li>
&lt;li>第三段是server与下游的短连接或连接池(pooled connections)，这些连接从属于第二段中的相同RemoteSide的虚拟连接。&lt;/li>
&lt;/ul>
&lt;p>表格标题的含义：&lt;/p>
&lt;ul>
&lt;li>RemoteSide : 远端的ip和端口。&lt;/li>
&lt;li>SSL：是否使用SSL加密，若为Yes的话，一般是HTTPS连接。&lt;/li>
&lt;li>Protocol : 使用的协议，可能为baidu_std hulu_pbrpc sofa_pbrpc memcache http public_pbrpc nova_pbrpc nshead_server等。&lt;/li>
&lt;li>fd : file descriptor（文件描述符），可能为-1。&lt;/li>
&lt;li>BytesIn/s : 上一秒读入的字节数&lt;/li>
&lt;li>In/s : 上一秒读入的消息数（消息是对request和response的统称）&lt;/li>
&lt;li>BytesOut/s : 上一秒写出的字节数&lt;/li>
&lt;li>Out/s : 上一秒写出的消息数&lt;/li>
&lt;li>BytesIn/m: 上一分钟读入的字节数&lt;/li>
&lt;li>In/m: 上一分钟读入的消息数&lt;/li>
&lt;li>BytesOut/m: 上一分钟写出的字节数&lt;/li>
&lt;li>Out/m: 上一分钟写出的消息数&lt;/li>
&lt;li>SocketId ：内部id，用于debug，用户不用关心。&lt;/li>
&lt;/ul>
&lt;p>典型截图分别如下所示：&lt;/p>
&lt;p>单连接：&lt;img src="https://brpc.apache.org/images/docs/single_conn.png" alt="img">&lt;/p>
&lt;p>连接池：&lt;img src="https://brpc.apache.org/images/docs/pooled_conn.png" alt="img">&lt;/p>
&lt;p>短连接：&lt;img src="https://brpc.apache.org/images/docs/short_conn.png" alt="img">&lt;/p></description></item><item><title>Docs: flags</title><link>https://brpc.apache.org/docs/builtin-services/flags/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/flags/</guid><description>
&lt;p>brpc使用gflags管理配置。如果你的程序也使用gflags，那么你应该已经可以修改和brpc相关的flags，你可以浏览&lt;a href="http://brpc.baidu.com:8765/flags">flags服务&lt;/a>了解每个flag的具体功能。如果你的程序还没有使用gflags，我们建议你使用，原因如下：&lt;/p>
&lt;ul>
&lt;li>命令行和文件均可传入，前者方便做测试，后者适合线上运维。放在文件中的gflags可以reload。而configure只支持从文件读取配置。&lt;/li>
&lt;li>你可以在浏览器中查看brpc服务器中所有gflags，并对其动态修改（如果允许的话）。configure不可能做到这点。&lt;/li>
&lt;li>gflags分散在和其作用紧密关联的文件中，更好管理。而使用configure需要聚集到一个庞大的读取函数中。&lt;/li>
&lt;/ul>
&lt;h1 id="usage-of-gflags">Usage of gflags&lt;/h1>
&lt;p>gflags一般定义在需要它的源文件中。#include &amp;lt;gflags/gflags.h&amp;gt;后在全局scope加入DEFINE_&lt;em>&amp;lt;type&amp;gt;&lt;/em>(&lt;em>&amp;lt;name&amp;gt;&lt;/em>, &lt;em>&amp;lt;default-value&amp;gt;&lt;/em>, &lt;em>&amp;lt;description&amp;gt;&lt;/em>); 比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#include&lt;/span> &lt;span style="color:#8f5902;font-style:italic">&amp;lt;gflags/gflags.h&amp;gt;&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_bool&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">hex_log_id&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">false&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Show log_id in hexadecimal&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_int32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">health_check_interval&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;seconds between consecutive health-checkings&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般在main函数开头用ParseCommandLineFlags处理程序参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#include&lt;/span> &lt;span style="color:#8f5902;font-style:italic">&amp;lt;gflags/gflags.h&amp;gt;&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">argc&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">argv&lt;/span>&lt;span style="color:#000;font-weight:bold">[])&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">google&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">ParseCommandLineFlags&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">argc&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">argv&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">true&lt;/span>&lt;span style="color:#8f5902;font-style:italic">/*表示把识别的参数从argc/argv中删除*/&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果要从conf/gflags.conf中加载gflags，则可以加上参数-flagfile=conf/gflags.conf。如果希望默认（什么参数都不加）就从文件中读取，则可以在程序中直接给flagfile赋值，一般这么写&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">google&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">SetCommandLineOption&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;flagfile&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;conf/gflags.conf&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>程序启动时会检查conf/gflags.conf是否存在，如果不存在则会报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ ./my_program
conf/gflags.conf: No such file or directory
&lt;/code>&lt;/pre>&lt;p>更具体的使用指南请阅读&lt;a href="http://gflags.github.io/gflags/">官方文档&lt;/a>。&lt;/p>
&lt;h1 id="flagfile">flagfile&lt;/h1>
&lt;p>在命令行中参数和值之间可不加等号，而在flagfile中一定要加。比如&lt;code>./myapp -param 7&lt;/code>是ok的，但在&lt;code>./myapp -flagfile=./gflags.conf&lt;/code>对应的gflags.conf中一定要写成 &lt;strong>-param=7&lt;/strong> 或 &lt;strong>&amp;ndash;param=7&lt;/strong>，否则就不正确且不会报错。&lt;/p>
&lt;p>在命令行中字符串可用单引号或双引号包围，而在flagfile中不能加。比如&lt;code>./myapp -name=&amp;quot;tom&amp;quot;&lt;/code>或&lt;code>./myapp -name='tom'&lt;/code>都是ok的，但在&lt;code>./myapp -flagfile=./gflags.conf&lt;/code>对应的gflags.conf中一定要写成 &lt;strong>-name=tom&lt;/strong> 或 &lt;strong>&amp;ndash;name=tom&lt;/strong>，如果写成-name=&amp;ldquo;tom&amp;quot;的话，引号也会作为值的一部分。配置文件中的值可以有空格，比如gflags.conf中写成-name=value with spaces是ok的，参数name的值就是value with spaces，而在命令行中要用引号括起来。&lt;/p>
&lt;p>flagfile中参数可由单横线(如-foo)或双横线(如&amp;ndash;foo)打头，但不能以三横线或更多横线打头，否则的话是无效参数且不会报错!&lt;/p>
&lt;p>flagfile中以&lt;code>#开头的行被认为是注释。开头的空格和空白行都会被忽略。&lt;/code>&lt;/p>
&lt;p>flagfile中可以使用&lt;code>--flagfile包含另一个flagfile。&lt;/code>&lt;/p>
&lt;h1 id="change-gflag-on-the-fly">Change gflag on-the-fly&lt;/h1>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/flags">flags服务&lt;/a>可以查看服务器进程中所有的gflags。修改过的flags会以红色高亮。“修改过”指的是修改这一行为，即使再改回默认值，仍然会显示为红色。&lt;/p>
&lt;p>/flags：列出所有的gflags&lt;/p>
&lt;p>/flags/NAME：查询名字为NAME的gflag&lt;/p>
&lt;p>/flags/NAME1,NAME2,NAME3：查询名字为NAME1或NAME2或NAME3的gflag&lt;/p>
&lt;p>/flags/foo*,b$r：查询名字与某一统配符匹配的gflag，注意用$代替?匹配单个字符，因为?在url中有特殊含义。&lt;/p>
&lt;p>访问/flags/NAME?setvalue=VALUE即可动态修改一个gflag的值，validator会被调用。&lt;/p>
&lt;p>为了防止误修改，需要动态修改的gflag必须有validator，显示此类gflag名字时有(R)后缀。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/reloadable_flags.png" alt="img">&lt;/p>
&lt;p>&lt;em>修改成功后会显示如下信息&lt;/em>：&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/flag_setvalue.png" alt="img">&lt;/p>
&lt;p>&lt;em>尝试修改不允许修改的gflag会显示如下错误信息&lt;/em>：&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/set_flag_reject.png" alt="img">&lt;/p>
&lt;p>&lt;em>设置一个不允许的值会显示如下错误（flag值不会变化）&lt;/em>：&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/set_flag_invalid_value.png" alt="img">&lt;/p>
&lt;p>r31658之后支持可视化地修改，在浏览器上访问时将看到(R)下多了下划线：&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/the_r_after_flag.png" alt="img">&lt;/p>
&lt;p>点击后在一个独立页面可视化地修改对应的flag：&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/set_flag_with_form.png" alt="img">&lt;/p>
&lt;p>填入true后确定：&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/set_flag_with_form_2.png" alt="img">&lt;/p>
&lt;p>返回/flags可以看到对应的flag已经被修改了：&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/set_flag_with_form_3.png" alt="img">&lt;/p>
&lt;p>关于重载gflags，重点关注：&lt;/p>
&lt;ul>
&lt;li>避免在一段代码中多次调用同一个gflag，应把该gflag的值保存下来并调用该值。因为gflag的值随时可能变化，而产生意想不到的结果。&lt;/li>
&lt;li>使用google::GetCommandLineOption()访问string类型的gflag，直接访问是线程不安全的。&lt;/li>
&lt;li>处理逻辑和副作用应放到validator里去。比如修改FLAGS_foo后得更新另一处的值，如果只是写在程序初始化的地方，而不是validator里，那么重载时这段逻辑就运行不到了。&lt;/li>
&lt;/ul>
&lt;p>如果你确认某个gflag不需要额外的线程同步和处理逻辑就可以重载，那么可以用如下方式为其注册一个总是返回true的validator：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_bool&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">hex_log_id&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">false&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Show log_id in hexadecimal&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">BRPC_VALIDATE_GFLAG&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">hex_log_id&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">PassValidate&lt;/span>&lt;span style="color:#8f5902;font-style:italic">/*always true*/&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个flag是单纯的开关，修改后不需要更新其他数据（没有处理逻辑），代码中前面看到true后面看到false也不会产生什么后果（不需要线程同步），所以我们让其默认可重载。&lt;/p>
&lt;p>对于int32和int64类型，有一个判断是否为正数的常用validator：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_int32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">health_check_interval&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;seconds between consecutive health-checkings&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">BRPC_VALIDATE_GFLAG&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">health_check_interval&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">PositiveInteger&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上操作都可以在命令行中进行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ curl brpc.baidu.com:8765/flags/health_check_interval
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name &lt;span style="color:#000;font-weight:bold">|&lt;/span> Value &lt;span style="color:#000;font-weight:bold">|&lt;/span> Description &lt;span style="color:#000;font-weight:bold">|&lt;/span> Defined At
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>health_check_interval &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>R&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> seconds between consecutive health-checkings &lt;span style="color:#000;font-weight:bold">|&lt;/span> src/brpc/socket_map.cpp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>1.0.251.32399后增加了-immutable_flags，打开后所有的gflags将不能被动态修改。当一个服务对某个gflag值比较敏感且不希望在线上被误改，可打开这个开关。打开这个开关的同时也意味着你无法动态修改线上的配置，每次修改都要重启程序，对于还在调试阶段或待收敛阶段的程序不建议打开。&lt;/p></description></item><item><title>Docs: rpcz</title><link>https://brpc.apache.org/docs/builtin-services/rpcz/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/rpcz/</guid><description>
&lt;p>用户能通过/rpcz看到最近请求的详细信息，并可以插入注释（annotation），不同于tracing system（如&lt;a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf">dapper&lt;/a>）以全局视角看到整体系统的延时分布，rpcz更多是一个调试工具，虽然角色有所不同，但在brpc中rpcz和tracing的数据来源是一样的。当每秒请求数小于1万时，rpcz会记录所有的请求，超过1万时，rpcz会随机忽略一些请求把采样数控制在1万左右。rpcz可以淘汰时间窗口之前的数据，通过-span_keeping_seconds选项设置，默认1小时。&lt;a href="http://brpc.baidu.com:8765/rpcz">一个长期运行的例子&lt;/a>。&lt;/p>
&lt;p>关于开销：我们的实现完全规避了线程竞争，开销极小，在qps 30万的测试场景中，观察不到明显的性能变化，对大部分应用而言应该是“free”的。即使采集了几千万条请求，rpcz也不会增加很多内存，一般在50兆以内。rpcz会占用一些磁盘空间（就像日志一样），如果设定为存一个小时的数据，一般在几百兆左右。&lt;/p>
&lt;h2 id="开关方法">开关方法&lt;/h2>
&lt;p>默认不开启，加入&lt;a href="http://brpc.baidu.com:8765/flags/*rpcz*">-enable_rpcz&lt;/a>选项会在启动后开启。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Value&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Defined At&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>enable_rpcz (R)&lt;/td>
&lt;td>true (default:false)&lt;/td>
&lt;td>Turn on rpcz&lt;/td>
&lt;td>src/baidu/rpc/builtin/rpcz_service.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_hex_log_id (R)&lt;/td>
&lt;td>false&lt;/td>
&lt;td>Show log_id in hexadecimal&lt;/td>
&lt;td>src/baidu/rpc/builtin/rpcz_service.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_database_dir&lt;/td>
&lt;td>./rpc_data/rpcz&lt;/td>
&lt;td>For storing requests/contexts collected by rpcz.&lt;/td>
&lt;td>src/baidu/rpc/span.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_keep_span_db&lt;/td>
&lt;td>false&lt;/td>
&lt;td>Don&amp;rsquo;t remove DB of rpcz at program&amp;rsquo;s exit&lt;/td>
&lt;td>src/baidu/rpc/span.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_keep_span_seconds (R)&lt;/td>
&lt;td>3600&lt;/td>
&lt;td>Keep spans for at most so many seconds&lt;/td>
&lt;td>src/baidu/rpc/span.cpp&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>若启动时未加-enable_rpcz，则可在启动后访问SERVER_URL/rpcz/enable动态开启rpcz，访问SERVER_URL/rpcz/disable则关闭，这两个链接等价于访问SERVER_URL/flags/enable_rpcz?setvalue=true和SERVER_URL/flags/enable_rpcz?setvalue=false。在r31010之后，rpc在html版本中增加了一个按钮可视化地开启和关闭。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/rpcz_4.png" alt="img">&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/rpcz_5.png" alt="img">&lt;/p>
&lt;p>如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/p>
&lt;h2 id="数据展现">数据展现&lt;/h2>
&lt;p>/rpcz展现的数据分为两层。&lt;/p>
&lt;h3 id="第一层">第一层&lt;/h3>
&lt;p>看到最新请求的概况，点击链接进入第二层。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/rpcz_6.png" alt="img">&lt;/p>
&lt;h3 id="第二层">第二层&lt;/h3>
&lt;p>看到某系列(trace)或某个请求(span)的详细信息。一般通过点击链接进入，也可以把trace=和span=作为query-string拼出链接&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/rpcz_7.png" alt="img">&lt;/p>
&lt;p>内容说明：&lt;/p>
&lt;ul>
&lt;li>时间分为了绝对时间（如2015/01/21-20:20:30.817392，小数点后精确到微秒）和前一个时间的差值（如. 19，代表19微秒)。&lt;/li>
&lt;li>trace=ID有点像“session id”，对应一个系统中完成一次对外服务牵涉到的所有服务，即上下游server都共用一个trace-id。span=ID对应一个server或client中一个请求的处理过程。trace-id和span-id在概率上唯一。&lt;/li>
&lt;li>第一层页面中的request=和response=后的是数据包的字节数，包括附件但不包括协议meta。第二层中request和response的字节数一般在括号里，比如&amp;quot;Responded(13)&amp;ldquo;中的13。&lt;/li>
&lt;li>点击链接可能会访问其他server上的rpcz，点浏览器后退一般会返回到之前的页面位置。&lt;/li>
&lt;li>I&amp;rsquo;m the last call, I&amp;rsquo;m about to &amp;hellip;都是用户的annotation。&lt;/li>
&lt;/ul>
&lt;h2 id="annotation">Annotation&lt;/h2>
&lt;p>只要你使用了brpc，就可以使用&lt;a href="https://github.com/brpc/brpc/blob/master/src/brpc/traceprintf.h">TRACEPRINTF&lt;/a>打印内容到事件流中，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">TRACEPRINTF&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hello rpcz %d&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">123&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这条annotation会按其发生时间插入到对应请求的rpcz中。从这个角度看，rpcz是请求级的日志。如果你用TRACEPRINTF打印了沿路的上下文，便可看到请求在每个阶段停留的时间，牵涉到的数据集和参数。这是个很有用的功能。&lt;/p></description></item><item><title>Docs: cpu profiler</title><link>https://brpc.apache.org/docs/builtin-services/cpu_profiler/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/cpu_profiler/</guid><description>
&lt;p>brpc可以分析程序中的热点函数。&lt;/p>
&lt;h1 id="开启方法">开启方法&lt;/h1>
&lt;ol>
&lt;li>链接&lt;code>libtcmalloc_and_profiler.a&lt;/code>
&lt;ol>
&lt;li>这么写也开启了tcmalloc，不建议单独链接cpu profiler而不链接tcmalloc，可能越界访问导致&lt;a href="https://github.com/gperftools/gperftools/blob/master/README#L226">crash&lt;/a>.可能由于tcmalloc不及时归还内存，越界访问不会crash。&lt;/li>
&lt;li>如果tcmalloc使用frame pointer而不是libunwind回溯栈，请确保在CXXFLAGS或CFLAGS中加上&lt;code>-fno-omit-frame-pointer&lt;/code>，否则函数间的调用关系会丢失，最后产生的图片中都是彼此独立的函数方框。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>定义宏BRPC_ENABLE_CPU_PROFILER, 一般加入编译参数-DBRPC_ENABLE_CPU_PROFILER。&lt;/li>
&lt;li>如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/li>
&lt;/ol>
&lt;p>注意要关闭Server端的认证，否则可能会看到这个：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text localhost:9002/pprof/profile
Use of uninitialized value in substitution (s///) at tools/pprof line 2703.
http://localhost:9002/profile/symbol doesn&amp;#39;t exist
&lt;/code>&lt;/pre>&lt;p>server端可能会有这样的日志：&lt;/p>
&lt;pre tabindex="0">&lt;code>FATAL: 12-26 10:01:25: * 0 [src/brpc/policy/giano_authenticator.cpp:65][4294969345] Giano fails to verify credentical, 70003
WARNING: 12-26 10:01:25: * 0 [src/brpc/input_messenger.cpp:132][4294969345] Authentication failed, remote side(127.0.0.1:22989) of sockfd=5, close it
&lt;/code>&lt;/pre>&lt;h1 id="查看方法">查看方法&lt;/h1>
&lt;ol>
&lt;li>通过builtin service的 /hotspots/cpu 页面查看&lt;/li>
&lt;li>通过pprof 工具查看，如 tools/pprof &amp;ndash;text localhost:9002/pprof/profile&lt;/li>
&lt;/ol>
&lt;h1 id="控制采样频率">控制采样频率&lt;/h1>
&lt;p>启动前设置环境变量：export CPUPROFILE_FREQUENCY=xxx&lt;/p>
&lt;p>默认值为: 100&lt;/p>
&lt;h1 id="控制采样时间">控制采样时间&lt;/h1>
&lt;p>url加上?seconds=秒数，如/hotspots/cpu?seconds=5&lt;/p>
&lt;h1 id="图示">图示&lt;/h1>
&lt;p>下图是一次运行cpu profiler后的结果：&lt;/p>
&lt;ul>
&lt;li>左上角是总体信息，包括时间，程序名，总采样数等等。&lt;/li>
&lt;li>View框中可以选择查看之前运行过的profile结果，Diff框中可选择查看和之前的结果的变化量，重启后清空。&lt;/li>
&lt;li>代表函数调用的方框中的字段从上到下依次为：函数名，这个函数本身（除去所有子函数）占的采样数和比例，这个函数及调用的所有子函数累计的采样数和比例。采样数越大框越大。&lt;/li>
&lt;li>方框之间连线上的数字表示被采样到的上层函数对下层函数的调用数，数字越大线越粗。&lt;/li>
&lt;/ul>
&lt;p>热点分析一般开始于找到最大的框最粗的线考察其来源及去向。&lt;/p>
&lt;p>cpu profiler的原理是在定期被调用的SIGPROF handler中采样所在线程的栈，由于handler（在linux 2.6后）会被随机地摆放于活跃线程的栈上运行，cpu profiler在运行一段时间后能以很大的概率采集到所有活跃线程中的活跃函数，最后根据栈代表的函数调用关系汇总为调用图，并把地址转换成符号，这就是我们看到的结果图了。采集频率由环境变量CPUPROFILE_FREQUENCY控制，默认100，即每秒钟100次或每10ms一次。在实践中cpu profiler对原程序的影响不明显。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/echo_cpu_profiling.png" alt="img">&lt;/p>
&lt;p>在Linux下，你也可以使用&lt;a href="https://github.com/brpc/brpc/blob/master/tools/pprof">pprof&lt;/a>或gperftools中的pprof进行profiling。&lt;/p>
&lt;p>比如&lt;code>pprof --text localhost:9002 --seconds=5&lt;/code>的意思是统计运行在本机9002端口的server的cpu情况，时长5秒。一次运行的例子如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text 0.0.0.0:9002 --seconds=5
Gathering CPU profile from http://0.0.0.0:9002/pprof/profile?seconds=5 for 5 seconds to
/home/gejun/pprof/echo_server.1419501210.0.0.0.0
Be patient...
Wrote profile to /home/gejun/pprof/echo_server.1419501210.0.0.0.0
Removing funlockfile from all stack traces.
Total: 2946 samples
1161 39.4% 39.4% 1161 39.4% syscall
248 8.4% 47.8% 248 8.4% bthread::TaskControl::steal_task
227 7.7% 55.5% 227 7.7% writev
87 3.0% 58.5% 88 3.0% ::cpp_alloc
74 2.5% 61.0% 74 2.5% __read_nocancel
46 1.6% 62.6% 48 1.6% tc_delete
42 1.4% 64.0% 42 1.4% brpc::Socket::Address
41 1.4% 65.4% 41 1.4% epoll_wait
35 1.2% 66.6% 35 1.2% memcpy
33 1.1% 67.7% 33 1.1% __pthread_getspecific
33 1.1% 68.8% 33 1.1% brpc::Socket::Write
33 1.1% 69.9% 33 1.1% epoll_ctl
28 1.0% 70.9% 42 1.4% brpc::policy::ProcessRpcRequest
27 0.9% 71.8% 27 0.9% butil::IOBuf::_push_back_ref
27 0.9% 72.7% 27 0.9% bthread::TaskGroup::ending_sched
&lt;/code>&lt;/pre>&lt;p>省略–text进入交互模式，如下图所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof localhost:9002 --seconds=5
Gathering CPU profile from http://0.0.0.0:9002/pprof/profile?seconds=5 for 5 seconds to
/home/gejun/pprof/echo_server.1419501236.0.0.0.0
Be patient...
Wrote profile to /home/gejun/pprof/echo_server.1419501236.0.0.0.0
Removing funlockfile from all stack traces.
Welcome to pprof! For help, type &amp;#39;help&amp;#39;.
(pprof) top
Total: 2954 samples
1099 37.2% 37.2% 1099 37.2% syscall
253 8.6% 45.8% 253 8.6% bthread::TaskControl::steal_task
240 8.1% 53.9% 240 8.1% writev
90 3.0% 56.9% 90 3.0% ::cpp_alloc
67 2.3% 59.2% 67 2.3% __read_nocancel
47 1.6% 60.8% 47 1.6% butil::IOBuf::_push_back_ref
42 1.4% 62.2% 56 1.9% brpc::policy::ProcessRpcRequest
41 1.4% 63.6% 41 1.4% epoll_wait
38 1.3% 64.9% 38 1.3% epoll_ctl
37 1.3% 66.1% 37 1.3% memcpy
35 1.2% 67.3% 35 1.2% brpc::Socket::Address
&lt;/code>&lt;/pre>&lt;h1 id="macos的额外配置">MacOS的额外配置&lt;/h1>
&lt;p>在MacOS下，gperftools中的perl pprof脚本无法将函数地址转变成函数名，解决办法是：&lt;/p>
&lt;ol>
&lt;li>安装&lt;a href="https://github.com/google/pprof">standalone pprof&lt;/a>，并把下载的pprof二进制文件路径写入环境变量GOOGLE_PPROF_BINARY_PATH中&lt;/li>
&lt;li>安装llvm-symbolizer（将函数符号转化为函数名），直接用brew安装即可：&lt;code>brew install llvm&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="火焰图">火焰图&lt;/h1>
&lt;p>若需要结果以火焰图的方式展示，请下载并安装&lt;a href="https://github.com/brendangregg/FlameGraph">FlameGraph&lt;/a>工具，将环境变量FLAMEGRAPH_PL_PATH正确设置到本地的/path/to/flamegraph.pl后启动server即可。&lt;/p></description></item><item><title>Docs: heap profiler</title><link>https://brpc.apache.org/docs/builtin-services/heap_profiler/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/heap_profiler/</guid><description>
&lt;p>brpc可以分析内存是被哪些函数占据的。heap profiler的原理是每分配满一些内存就采样调用处的栈，“一些”由环境变量TCMALLOC_SAMPLE_PARAMETER控制，默认524288，即512K字节。根据栈表现出的函数调用关系汇总为我们看到的结果图。在实践中heap profiler对原程序的影响不明显。&lt;/p>
&lt;h1 id="开启方法">开启方法&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>链接&lt;code>libtcmalloc_and_profiler.a&lt;/code>&lt;/p>
&lt;ol>
&lt;li>如果tcmalloc使用frame pointer而不是libunwind回溯栈，请确保在CXXFLAGS或CFLAGS中加上&lt;code>-fno-omit-frame-pointer&lt;/code>，否则函数间的调用关系会丢失，最后产生的图片中都是彼此独立的函数方框。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>在shell中&lt;code>export TCMALLOC_SAMPLE_PARAMETER=524288&lt;/code>。该变量指每分配这么多字节内存时做一次统计，默认为0，代表不开启内存统计。&lt;a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">官方文档&lt;/a>建议设置为524288。这个变量也可在运行前临时设置，如&lt;code>TCMALLOC_SAMPLE_PARAMETER=524288 ./server&lt;/code>。如果没有这个环境变量，可能会看到这样的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text localhost:9002/pprof/heap
Fetching /pprof/heap profile from http://localhost:9002/pprof/heap to
/home/gejun/pprof/echo_server.1419559063.localhost.pprof.heap
Wrote profile to /home/gejun/pprof/echo_server.1419559063.localhost.pprof.heap
/home/gejun/pprof/echo_server.1419559063.localhost.pprof.heap: header size &amp;gt;= 2**16
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>注意要关闭Server端的认证，否则可能会看到这个：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text localhost:9002/pprof/heap
Use of uninitialized value in substitution (s///) at tools/pprof line 2703.
http://localhost:9002/pprof/symbol doesn&amp;#39;t exist
&lt;/code>&lt;/pre>&lt;p>server端可能会有这样的日志：&lt;/p>
&lt;pre tabindex="0">&lt;code>FATAL: 12-26 10:01:25: * 0 [src/brpc/policy/giano_authenticator.cpp:65][4294969345] Giano fails to verify credentical, 70003
WARNING: 12-26 10:01:25: * 0 [src/brpc/input_messenger.cpp:132][4294969345] Authentication failed, remote side(127.0.0.1:22989) of sockfd=5, close it
&lt;/code>&lt;/pre>&lt;h1 id="图示">图示&lt;/h1>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/heap_profiler_1.png" alt="img">&lt;/p>
&lt;p>左上角是当前程序通过malloc分配的内存总量，顺着箭头上的数字可以看到内存来自哪些函数。&lt;/p>
&lt;p>点击左上角的text选择框可以查看文本格式的结果，有时候这种按分配量排序的形式更方便。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/heap_profiler_2.png" alt="img">&lt;/p>
&lt;p>左上角的两个选择框作用分别是：&lt;/p>
&lt;ul>
&lt;li>View：当前正在看的profile。选择&amp;lt;new profile&amp;gt;表示新建一个。新建完毕后，View选择框中会出现新profile，URL也会被修改为对应的地址。这意味着你可以通过粘贴URL分享结果，点击链接的人将看到和你一模一样的结果，而不是重做profiling的结果。你可以在框中选择之前的profile查看。历史profiie保留最近的32个，可通过&lt;a href="http://brpc.baidu.com:8765/flags/max_profiles_kept">&amp;ndash;max_profiles_kept&lt;/a>调整。&lt;/li>
&lt;li>Diff：和选择的profile做对比。&lt;none>表示什么都不选。如果你选择了之前的某个profile，那么将看到View框中的profile相比Diff框中profile的变化量。&lt;/li>
&lt;/ul>
&lt;p>下图演示了勾选Diff和Text的效果。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/heap_profiler_3.gif" alt="img">&lt;/p>
&lt;p>在Linux下，你也可以使用pprof脚本（tools/pprof）在命令行中查看文本格式结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text db-rpc-dev00.db01:8765/pprof/heap
Fetching /pprof/heap profile from http://db-rpc-dev00.db01:8765/pprof/heap to
/home/gejun/pprof/play_server.1453216025.db-rpc-dev00.db01.pprof.heap
Wrote profile to /home/gejun/pprof/play_server.1453216025.db-rpc-dev00.db01.pprof.heap
Adjusting heap profiles for 1-in-524288 sampling rate
Heap version 2
Total: 38.9 MB
35.8 92.0% 92.0% 35.8 92.0% ::cpp_alloc
2.1 5.4% 97.4% 2.1 5.4% butil::FlatMap
0.5 1.3% 98.7% 0.5 1.3% butil::IOBuf::append
0.5 1.3% 100.0% 0.5 1.3% butil::IOBufAsZeroCopyOutputStream::Next
0.0 0.0% 100.0% 0.6 1.5% MallocExtension::GetHeapSample
0.0 0.0% 100.0% 0.5 1.3% ProfileHandler::Init
0.0 0.0% 100.0% 0.5 1.3% ProfileHandlerRegisterCallback
0.0 0.0% 100.0% 0.5 1.3% __do_global_ctors_aux
0.0 0.0% 100.0% 1.6 4.2% _end
0.0 0.0% 100.0% 0.5 1.3% _init
0.0 0.0% 100.0% 0.6 1.5% brpc::CloseIdleConnections
0.0 0.0% 100.0% 1.1 2.9% brpc::GlobalUpdate
0.0 0.0% 100.0% 0.6 1.5% brpc::PProfService::heap
0.0 0.0% 100.0% 1.9 4.9% brpc::Socket::Create
0.0 0.0% 100.0% 2.9 7.4% brpc::Socket::Write
0.0 0.0% 100.0% 3.8 9.7% brpc::Span::CreateServerSpan
0.0 0.0% 100.0% 1.4 3.5% brpc::SpanQueue::Push
0.0 0.0% 100.0% 1.9 4.8% butil::ObjectPool
0.0 0.0% 100.0% 0.8 2.0% butil::ResourcePool
0.0 0.0% 100.0% 1.0 2.6% butil::iobuf::tls_block
0.0 0.0% 100.0% 1.0 2.6% bthread::TimerThread::Bucket::schedule
0.0 0.0% 100.0% 1.6 4.1% bthread::get_stack
0.0 0.0% 100.0% 4.2 10.8% bthread_id_create
0.0 0.0% 100.0% 1.1 2.9% bvar::Variable::describe_series_exposed
0.0 0.0% 100.0% 1.0 2.6% bvar::detail::AgentGroup
0.0 0.0% 100.0% 0.5 1.3% bvar::detail::Percentile::operator
0.0 0.0% 100.0% 0.5 1.3% bvar::detail::PercentileSamples
0.0 0.0% 100.0% 0.5 1.3% bvar::detail::Sampler::schedule
0.0 0.0% 100.0% 6.5 16.8% leveldb::Arena::AllocateNewBlock
0.0 0.0% 100.0% 0.5 1.3% leveldb::VersionSet::LogAndApply
0.0 0.0% 100.0% 4.2 10.8% pthread_mutex_unlock
0.0 0.0% 100.0% 0.5 1.3% pthread_once
0.0 0.0% 100.0% 0.5 1.3% std::_Rb_tree
0.0 0.0% 100.0% 1.5 3.9% std::basic_string
0.0 0.0% 100.0% 3.5 9.0% std::string::_Rep::_S_create
&lt;/code>&lt;/pre>&lt;p>brpc还提供一个类似的growth profiler分析内存的分配去向（不考虑释放）。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/growth_profiler.png" alt="img">&lt;/p>
&lt;h1 id="macos的额外配置">MacOS的额外配置&lt;/h1>
&lt;ol>
&lt;li>安装&lt;a href="https://github.com/google/pprof">standalone pprof&lt;/a>，并把下载的pprof二进制文件路径写入环境变量GOOGLE_PPROF_BINARY_PATH中&lt;/li>
&lt;li>安装llvm-symbolizer（将函数符号转化为函数名），直接用brew安装即可：&lt;code>brew install llvm&lt;/code>&lt;/li>
&lt;/ol></description></item><item><title>Docs: contention profiler</title><link>https://brpc.apache.org/docs/builtin-services/contention_profiler/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.apache.org/docs/builtin-services/contention_profiler/</guid><description>
&lt;p>brpc可以分析花在等待锁上的时间及发生等待的函数。&lt;/p>
&lt;h1 id="开启方法">开启方法&lt;/h1>
&lt;p>按需开启。无需配置，不依赖tcmalloc，不需要链接frame pointer或libunwind。如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/p>
&lt;h1 id="图示">图示&lt;/h1>
&lt;p>当很多线程争抢同一把锁时，一些线程无法立刻获得锁，而必须睡眠直到某个线程退出临界区。这个争抢过程我们称之为&lt;strong>contention&lt;/strong>。在多核机器上，当多个线程需要操作同一个资源却被一把锁挡住时，便无法充分发挥多个核心的并发能力。现代OS通过提供比锁更底层的同步原语，使得无竞争锁完全不需要系统调用，只是一两条wait-free，耗时10-20ns的原子操作，非常快。而锁一旦发生竞争，一些线程就要陷入睡眠，再次醒来触发了OS的调度代码，代价至少为3-5us。所以让锁尽量无竞争，让所有线程“一起飞”是需要高性能的server的永恒话题。&lt;/p>
&lt;p>r31906后brpc支持contention profiler，可以分析在等待锁上花费了多少时间。等待过程中线程是睡着的不会占用CPU，所以contention profiler中的时间并不是cpu时间，也不会出现在&lt;a href="../cpu_profiler/">cpu profiler&lt;/a>中。cpu profiler可以抓到特别频繁的锁（以至于花费了很多cpu），但耗时真正巨大的临界区往往不是那么频繁，而无法被cpu profiler发现。**contention profiler和cpu profiler好似互补关系，前者分析等待时间（被动），后者分析忙碌时间。**还有一类由用户基于condition或sleep发起的主动等待时间，无需分析。&lt;/p>
&lt;p>目前contention profiler支持pthread_mutex_t（非递归）和bthread_mutex_t，开启后每秒最多采集1000个竞争锁，这个数字由参数-bvar_collector_expected_per_second控制（同时影响rpc_dump）。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Value&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Defined At&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>bvar_collector_expected_per_second&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>Expected number of samples to be collected per second&lt;/td>
&lt;td>bvar/collector.cpp&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果一秒内竞争锁的次数Ｎ超过了1000，那么每把锁会有1000/N的概率被采集。在我们的各类测试场景中（qps在10万-60万不等）没有观察到被采集程序的性能有明显变化。&lt;/p>
&lt;p>我们通过实际例子来看下如何使用contention profiler，点击“contention”按钮（more左侧）后就会开启默认10秒的分析过程。下图是libraft中的一个示例程序的锁状况，这个程序是3个节点复制组的leader，qps在10-12万左右。左上角的&lt;strong>Total seconds: 2.449&lt;/strong>是采集时间内（10秒）在锁上花费的所有等待时间。注意是“等待”，无竞争的锁不会被采集也不会出现在下图中。顺着箭头往下走能看到每份时间来自哪些函数。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/raft_contention_1.png" alt="img">&lt;/p>
&lt;p>上图有点大，让我们放大一个局部看看。下图红框中的0.768是这个局部中最大的数字，它代表raft::LogManager::get_entry在等待涉及到bvar::detail::UniqueLockBase的函数上共等待了0.768秒（10秒内）。我们如果觉得这个时间不符合预期，就可以去排查代码。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/raft_contention_2.png" alt="img">&lt;/p>
&lt;p>点击上方的count选择框，可以查看锁的竞争次数。选择后左上角变为了&lt;strong>Total samples: 439026&lt;/strong>，代表采集时间内总共的锁竞争次数（估算）。图中箭头上的数字也相应地变为了次数，而不是时间。对比同一份结果的时间和次数，可以更深入地理解竞争状况。&lt;/p>
&lt;p>&lt;img src="https://brpc.apache.org/images/docs/raft_contention_3.png" alt="img">&lt;/p></description></item></channel></rss>